{"version":3,"sources":["webpack://QRCodeStyling/webpack/universalModuleDefinition","webpack://QRCodeStyling/./src/tools/merge.ts","webpack://QRCodeStyling/./src/constants/errorCorrectionPercents.ts","webpack://QRCodeStyling/./src/core/QRDot.ts","webpack://QRCodeStyling/./src/constants/dotTypes.ts","webpack://QRCodeStyling/./src/core/QRCornerSquare.ts","webpack://QRCodeStyling/./src/constants/cornerSquareTypes.ts","webpack://QRCodeStyling/./src/core/QRCornerDot.ts","webpack://QRCodeStyling/./src/constants/cornerDotTypes.ts","webpack://QRCodeStyling/external \"canvas\"","webpack://QRCodeStyling/./src/core/QRCanvas.ts","webpack://QRCodeStyling/./src/tools/calculateImageSize.ts","webpack://QRCodeStyling/./src/constants/gradientTypes.ts","webpack://QRCodeStyling/./src/constants/qrTypes.ts","webpack://QRCodeStyling/./src/core/QROptions.ts","webpack://QRCodeStyling/./src/constants/errorCorrectionLevels.ts","webpack://QRCodeStyling/./src/tools/sanitizeOptions.ts","webpack://QRCodeStyling/external \"qrcode-generator\"","webpack://QRCodeStyling/./src/index.ts","webpack://QRCodeStyling/./src/core/QRCodeStyling.ts","webpack://QRCodeStyling/./src/tools/getMode.ts","webpack://QRCodeStyling/./src/constants/modes.ts","webpack://QRCodeStyling/webpack/bootstrap","webpack://QRCodeStyling/webpack/startup","webpack://QRCodeStyling/webpack/runtime/compat get default export","webpack://QRCodeStyling/webpack/runtime/define property getters","webpack://QRCodeStyling/webpack/runtime/hasOwnProperty shorthand"],"names":["root","factory","exports","module","define","amd","this","isObject","obj","Array","isArray","mergeDeep","target","sources","length","source","shift","undefined","Object","keys","forEach","key","targetValue","sourceValue","assign","L","M","Q","H","context","type","_context","_type","draw","x","y","size","getNeighbor","drawFunction","_drawDot","_drawClassy","_drawClassyRounded","_drawRounded","_drawExtraRounded","_drawSquare","call","_rotateFigure","rotation","cx","cy","translate","rotate","closePath","_basicDot","args","arc","Math","PI","_basicSquare","rect","_basicSideRounded","lineTo","_basicCornerRounded","_basicCornerExtraRounded","_basicCornersRounded","_basicCornersExtraRounded","leftNeighbor","rightNeighbor","topNeighbor","bottomNeighbor","neighborsCount","dotSize","_basicExtraRounded","require","squareMask","dotMask","options","_canvas","createCanvas","width","height","_options","getContext","getCanvas","clear","canvasContext","clearRect","drawQR","qr","count","getModuleCount","minSize","min","margin","floor","drawImageSize","hideXDots","hideYDots","_qr","image","loadImage","_image","imageOptions","qrOptions","coverLevel","imageSize","errorCorrectionPercents","errorCorrectionLevel","maxHiddenDots","originalHeight","originalWidth","maxHiddenAxisDots","hideDots","k","sqrt","ceil","round","calculateImageSize","drawBackground","drawDots","i","j","hideBackgroundDots","drawCorners","drawImage","backgroundOptions","gradient","gradientOptions","_createGradient","additionalRotation","colorStops","offset","color","addColorStop","fillStyle","fillRect","filter","xBeginning","yBeginning","dot","dotsOptions","beginPath","isDark","xOffset","yOffset","strokeStyle","fill","cornersSquareSize","cornersDotSize","column","row","cornersSquareOptions","cornersSquare","cornersDotOptions","cornersDot","Error","dx","dy","dw","dh","createRadialGradient","positiveRotation","x0","y0","x1","y1","tan","createLinearGradient","qrTypes","data","typeNumber","mode","crossOrigin","sanitizeGradient","newGradient","Number","map","colorStop","sanitizeOptions","newOptions","Boolean","addData","test","getMode","make","toPNGBuffer","toBuffer","toSVGBuffer","__webpack_module_cache__","__webpack_require__","moduleId","__webpack_modules__","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","get","prop","prototype","hasOwnProperty"],"mappings":"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","file":"qr-code-styling.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"QRCodeStyling\"] = factory();\n\telse\n\t\troot[\"QRCodeStyling\"] = factory();\n})(this, function() {\nreturn ","import { UnknownObject } from \"../types\";\n\nconst isObject = (obj: Record<string, unknown>): boolean => !!obj && typeof obj === \"object\" && !Array.isArray(obj);\n\nexport default function mergeDeep(target: UnknownObject, ...sources: UnknownObject[]): UnknownObject {\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (source === undefined || !isObject(target) || !isObject(source)) return target;\n  target = { ...target };\n  Object.keys(source).forEach((key: string): void => {\n    const targetValue = target[key];\n    const sourceValue = source[key];\n\n    if (Array.isArray(targetValue) && Array.isArray(sourceValue)) {\n      target[key] = sourceValue;\n    } else if (isObject(targetValue) && isObject(sourceValue)) {\n      target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);\n    } else {\n      target[key] = sourceValue;\n    }\n  });\n\n  return mergeDeep(target, ...sources);\n}\n","interface ErrorCorrectionPercents {\n  [key: string]: number;\n}\n\nexport default {\n  L: 0.07,\n  M: 0.15,\n  Q: 0.25,\n  H: 0.3\n} as ErrorCorrectionPercents;\n","import dotTypes from \"../constants/dotTypes\";\nimport { DotType } from \"../types\";\nimport { CanvasRenderingContext2D } from \"canvas\";\n\ntype GetNeighbor = (x: number, y: number) => boolean;\ntype DrawArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  getNeighbor: GetNeighbor;\n};\n\ntype BasicFigureDrawArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n};\n\ntype RotateFigureArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n  draw: () => void;\n};\n\nexport default class QRDot {\n  _context: CanvasRenderingContext2D;\n  _type: DotType;\n\n  constructor({ context, type }: { context: CanvasRenderingContext2D; type: DotType }) {\n    this._context = context;\n    this._type = type;\n  }\n\n  draw(x: number, y: number, size: number, getNeighbor: GetNeighbor): void {\n    const context = this._context;\n    const type = this._type;\n    let drawFunction;\n\n    switch (type) {\n      case dotTypes.dots:\n        drawFunction = this._drawDot;\n        break;\n      case dotTypes.classy:\n        drawFunction = this._drawClassy;\n        break;\n      case dotTypes.classyRounded:\n        drawFunction = this._drawClassyRounded;\n        break;\n      case dotTypes.rounded:\n        drawFunction = this._drawRounded;\n        break;\n      case dotTypes.extraRounded:\n        drawFunction = this._drawExtraRounded;\n        break;\n      case dotTypes.square:\n      default:\n        drawFunction = this._drawSquare;\n    }\n\n    drawFunction.call(this, { x, y, size, context, getNeighbor });\n  }\n\n  _rotateFigure({ x, y, size, context, rotation, draw }: RotateFigureArgs): void {\n    const cx = x + size / 2;\n    const cy = y + size / 2;\n\n    context.translate(cx, cy);\n    rotation && context.rotate(rotation);\n    draw();\n    context.closePath();\n    rotation && context.rotate(-rotation);\n    context.translate(-cx, -cy);\n  }\n\n  _basicDot(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(0, 0, size / 2, 0, Math.PI * 2);\n      }\n    });\n  }\n\n  _basicSquare(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.rect(-size / 2, -size / 2, size, size);\n      }\n    });\n  }\n\n  //if rotation === 0 - right side is rounded\n  _basicSideRounded(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(0, 0, size / 2, -Math.PI / 2, Math.PI / 2);\n        context.lineTo(-size / 2, size / 2);\n        context.lineTo(-size / 2, -size / 2);\n        context.lineTo(0, -size / 2);\n      }\n    });\n  }\n\n  //if rotation === 0 - top right corner is rounded\n  _basicCornerRounded(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(0, 0, size / 2, -Math.PI / 2, 0);\n        context.lineTo(size / 2, size / 2);\n        context.lineTo(-size / 2, size / 2);\n        context.lineTo(-size / 2, -size / 2);\n        context.lineTo(0, -size / 2);\n      }\n    });\n  }\n\n  //if rotation === 0 - top right corner is rounded\n  _basicCornerExtraRounded(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(-size / 2, size / 2, size, -Math.PI / 2, 0);\n        context.lineTo(-size / 2, size / 2);\n        context.lineTo(-size / 2, -size / 2);\n      }\n    });\n  }\n\n  _basicCornersRounded(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(0, 0, size / 2, -Math.PI / 2, 0);\n        context.lineTo(size / 2, size / 2);\n        context.lineTo(0, size / 2);\n        context.arc(0, 0, size / 2, Math.PI / 2, Math.PI);\n        context.lineTo(-size / 2, -size / 2);\n        context.lineTo(0, -size / 2);\n      }\n    });\n  }\n\n  _basicCornersExtraRounded(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(-size / 2, size / 2, size, -Math.PI / 2, 0);\n        context.arc(size / 2, -size / 2, size, Math.PI / 2, Math.PI);\n      }\n    });\n  }\n\n  _drawDot({ x, y, size, context }: DrawArgs): void {\n    this._basicDot({ x, y, size, context, rotation: 0 });\n  }\n\n  _drawSquare({ x, y, size, context }: DrawArgs): void {\n    this._basicSquare({ x, y, size, context, rotation: 0 });\n  }\n\n  _drawRounded({ x, y, size, context, getNeighbor }: DrawArgs): void {\n    const leftNeighbor = +getNeighbor(-1, 0);\n    const rightNeighbor = +getNeighbor(1, 0);\n    const topNeighbor = +getNeighbor(0, -1);\n    const bottomNeighbor = +getNeighbor(0, 1);\n\n    const neighborsCount = leftNeighbor + rightNeighbor + topNeighbor + bottomNeighbor;\n\n    if (neighborsCount === 0) {\n      this._basicDot({ x, y, size, context, rotation: 0 });\n      return;\n    }\n\n    if (neighborsCount > 2 || (leftNeighbor && rightNeighbor) || (topNeighbor && bottomNeighbor)) {\n      this._basicSquare({ x, y, size, context, rotation: 0 });\n      return;\n    }\n\n    if (neighborsCount === 2) {\n      let rotation = 0;\n\n      if (leftNeighbor && topNeighbor) {\n        rotation = Math.PI / 2;\n      } else if (topNeighbor && rightNeighbor) {\n        rotation = Math.PI;\n      } else if (rightNeighbor && bottomNeighbor) {\n        rotation = -Math.PI / 2;\n      }\n\n      this._basicCornerRounded({ x, y, size, context, rotation });\n      return;\n    }\n\n    if (neighborsCount === 1) {\n      let rotation = 0;\n\n      if (topNeighbor) {\n        rotation = Math.PI / 2;\n      } else if (rightNeighbor) {\n        rotation = Math.PI;\n      } else if (bottomNeighbor) {\n        rotation = -Math.PI / 2;\n      }\n\n      this._basicSideRounded({ x, y, size, context, rotation });\n      return;\n    }\n  }\n\n  _drawExtraRounded({ x, y, size, context, getNeighbor }: DrawArgs): void {\n    const leftNeighbor = +getNeighbor(-1, 0);\n    const rightNeighbor = +getNeighbor(1, 0);\n    const topNeighbor = +getNeighbor(0, -1);\n    const bottomNeighbor = +getNeighbor(0, 1);\n\n    const neighborsCount = leftNeighbor + rightNeighbor + topNeighbor + bottomNeighbor;\n\n    if (neighborsCount === 0) {\n      this._basicDot({ x, y, size, context, rotation: 0 });\n      return;\n    }\n\n    if (neighborsCount > 2 || (leftNeighbor && rightNeighbor) || (topNeighbor && bottomNeighbor)) {\n      this._basicSquare({ x, y, size, context, rotation: 0 });\n      return;\n    }\n\n    if (neighborsCount === 2) {\n      let rotation = 0;\n\n      if (leftNeighbor && topNeighbor) {\n        rotation = Math.PI / 2;\n      } else if (topNeighbor && rightNeighbor) {\n        rotation = Math.PI;\n      } else if (rightNeighbor && bottomNeighbor) {\n        rotation = -Math.PI / 2;\n      }\n\n      this._basicCornerExtraRounded({ x, y, size, context, rotation });\n      return;\n    }\n\n    if (neighborsCount === 1) {\n      let rotation = 0;\n\n      if (topNeighbor) {\n        rotation = Math.PI / 2;\n      } else if (rightNeighbor) {\n        rotation = Math.PI;\n      } else if (bottomNeighbor) {\n        rotation = -Math.PI / 2;\n      }\n\n      this._basicSideRounded({ x, y, size, context, rotation });\n      return;\n    }\n  }\n\n  _drawClassy({ x, y, size, context, getNeighbor }: DrawArgs): void {\n    const leftNeighbor = +getNeighbor(-1, 0);\n    const rightNeighbor = +getNeighbor(1, 0);\n    const topNeighbor = +getNeighbor(0, -1);\n    const bottomNeighbor = +getNeighbor(0, 1);\n\n    const neighborsCount = leftNeighbor + rightNeighbor + topNeighbor + bottomNeighbor;\n\n    if (neighborsCount === 0) {\n      this._basicCornersRounded({ x, y, size, context, rotation: Math.PI / 2 });\n      return;\n    }\n\n    if (!leftNeighbor && !topNeighbor) {\n      this._basicCornerRounded({ x, y, size, context, rotation: -Math.PI / 2 });\n      return;\n    }\n\n    if (!rightNeighbor && !bottomNeighbor) {\n      this._basicCornerRounded({ x, y, size, context, rotation: Math.PI / 2 });\n      return;\n    }\n\n    this._basicSquare({ x, y, size, context, rotation: 0 });\n  }\n\n  _drawClassyRounded({ x, y, size, context, getNeighbor }: DrawArgs): void {\n    const leftNeighbor = +getNeighbor(-1, 0);\n    const rightNeighbor = +getNeighbor(1, 0);\n    const topNeighbor = +getNeighbor(0, -1);\n    const bottomNeighbor = +getNeighbor(0, 1);\n\n    const neighborsCount = leftNeighbor + rightNeighbor + topNeighbor + bottomNeighbor;\n\n    if (neighborsCount === 0) {\n      this._basicCornersRounded({ x, y, size, context, rotation: Math.PI / 2 });\n      return;\n    }\n\n    if (!leftNeighbor && !topNeighbor) {\n      this._basicCornerExtraRounded({\n        x,\n        y,\n        size,\n        context,\n        rotation: -Math.PI / 2\n      });\n      return;\n    }\n\n    if (!rightNeighbor && !bottomNeighbor) {\n      this._basicCornerExtraRounded({\n        x,\n        y,\n        size,\n        context,\n        rotation: Math.PI / 2\n      });\n      return;\n    }\n\n    this._basicSquare({ x, y, size, context, rotation: 0 });\n  }\n}\n","import { DotTypes } from \"../types\";\n\nexport default {\n  dots: \"dots\",\n  rounded: \"rounded\",\n  classy: \"classy\",\n  classyRounded: \"classy-rounded\",\n  square: \"square\",\n  extraRounded: \"extra-rounded\"\n} as DotTypes;\n","import cornerSquareTypes from \"../constants/cornerSquareTypes\";\nimport { CornerSquareType } from \"../types\";\nimport { CanvasRenderingContext2D } from \"canvas\";\n\ntype DrawArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n};\n\ntype BasicFigureDrawArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n};\n\ntype RotateFigureArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n  draw: () => void;\n};\n\nexport default class QRCornerSquare {\n  _context: CanvasRenderingContext2D;\n  _type: CornerSquareType;\n\n  constructor({ context, type }: { context: CanvasRenderingContext2D; type: CornerSquareType }) {\n    this._context = context;\n    this._type = type;\n  }\n\n  draw(x: number, y: number, size: number, rotation: number): void {\n    const context = this._context;\n    const type = this._type;\n    let drawFunction;\n\n    switch (type) {\n      case cornerSquareTypes.square:\n        drawFunction = this._drawSquare;\n        break;\n      case cornerSquareTypes.extraRounded:\n        drawFunction = this._drawExtraRounded;\n        break;\n      case cornerSquareTypes.dot:\n      default:\n        drawFunction = this._drawDot;\n    }\n\n    drawFunction.call(this, { x, y, size, context, rotation });\n  }\n\n  _rotateFigure({ x, y, size, context, rotation, draw }: RotateFigureArgs): void {\n    const cx = x + size / 2;\n    const cy = y + size / 2;\n\n    context.translate(cx, cy);\n    rotation && context.rotate(rotation);\n    draw();\n    context.closePath();\n    rotation && context.rotate(-rotation);\n    context.translate(-cx, -cy);\n  }\n\n  _basicDot(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n    const dotSize = size / 7;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(0, 0, size / 2, 0, Math.PI * 2);\n        context.arc(0, 0, size / 2 - dotSize, 0, Math.PI * 2);\n      }\n    });\n  }\n\n  _basicSquare(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n    const dotSize = size / 7;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.rect(-size / 2, -size / 2, size, size);\n        context.rect(-size / 2 + dotSize, -size / 2 + dotSize, size - 2 * dotSize, size - 2 * dotSize);\n      }\n    });\n  }\n\n  _basicExtraRounded(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n    const dotSize = size / 7;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(-dotSize, -dotSize, 2.5 * dotSize, Math.PI, -Math.PI / 2);\n        context.lineTo(dotSize, -3.5 * dotSize);\n        context.arc(dotSize, -dotSize, 2.5 * dotSize, -Math.PI / 2, 0);\n        context.lineTo(3.5 * dotSize, -dotSize);\n        context.arc(dotSize, dotSize, 2.5 * dotSize, 0, Math.PI / 2);\n        context.lineTo(-dotSize, 3.5 * dotSize);\n        context.arc(-dotSize, dotSize, 2.5 * dotSize, Math.PI / 2, Math.PI);\n        context.lineTo(-3.5 * dotSize, -dotSize);\n\n        context.arc(-dotSize, -dotSize, 1.5 * dotSize, Math.PI, -Math.PI / 2);\n        context.lineTo(dotSize, -2.5 * dotSize);\n        context.arc(dotSize, -dotSize, 1.5 * dotSize, -Math.PI / 2, 0);\n        context.lineTo(2.5 * dotSize, -dotSize);\n        context.arc(dotSize, dotSize, 1.5 * dotSize, 0, Math.PI / 2);\n        context.lineTo(-dotSize, 2.5 * dotSize);\n        context.arc(-dotSize, dotSize, 1.5 * dotSize, Math.PI / 2, Math.PI);\n        context.lineTo(-2.5 * dotSize, -dotSize);\n      }\n    });\n  }\n\n  _drawDot({ x, y, size, context, rotation }: DrawArgs): void {\n    this._basicDot({ x, y, size, context, rotation });\n  }\n\n  _drawSquare({ x, y, size, context, rotation }: DrawArgs): void {\n    this._basicSquare({ x, y, size, context, rotation });\n  }\n\n  _drawExtraRounded({ x, y, size, context, rotation }: DrawArgs): void {\n    this._basicExtraRounded({ x, y, size, context, rotation });\n  }\n}\n","import { CornerSquareTypes } from \"../types\";\n\nexport default {\n  dot: \"dot\",\n  square: \"square\",\n  extraRounded: \"extra-rounded\"\n} as CornerSquareTypes;\n","import cornerDotTypes from \"../constants/cornerDotTypes\";\nimport { CornerDotType } from \"../types\";\nimport { CanvasRenderingContext2D } from \"canvas\";\n\ntype DrawArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n};\n\ntype BasicFigureDrawArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n};\n\ntype RotateFigureArgs = {\n  x: number;\n  y: number;\n  size: number;\n  context: CanvasRenderingContext2D;\n  rotation: number;\n  draw: () => void;\n};\n\nexport default class QRCornerDot {\n  _context: CanvasRenderingContext2D;\n  _type: CornerDotType;\n\n  constructor({ context, type }: { context: CanvasRenderingContext2D; type: CornerDotType }) {\n    this._context = context;\n    this._type = type;\n  }\n\n  draw(x: number, y: number, size: number, rotation: number): void {\n    const context = this._context;\n    const type = this._type;\n    let drawFunction;\n\n    switch (type) {\n      case cornerDotTypes.square:\n        drawFunction = this._drawSquare;\n        break;\n      case cornerDotTypes.dot:\n      default:\n        drawFunction = this._drawDot;\n    }\n\n    drawFunction.call(this, { x, y, size, context, rotation });\n  }\n\n  _rotateFigure({ x, y, size, context, rotation, draw }: RotateFigureArgs): void {\n    const cx = x + size / 2;\n    const cy = y + size / 2;\n\n    context.translate(cx, cy);\n    rotation && context.rotate(rotation);\n    draw();\n    context.closePath();\n    rotation && context.rotate(-rotation);\n    context.translate(-cx, -cy);\n  }\n\n  _basicDot(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.arc(0, 0, size / 2, 0, Math.PI * 2);\n      }\n    });\n  }\n\n  _basicSquare(args: BasicFigureDrawArgs): void {\n    const { size, context } = args;\n\n    this._rotateFigure({\n      ...args,\n      draw: () => {\n        context.rect(-size / 2, -size / 2, size, size);\n      }\n    });\n  }\n\n  _drawDot({ x, y, size, context, rotation }: DrawArgs): void {\n    this._basicDot({ x, y, size, context, rotation });\n  }\n\n  _drawSquare({ x, y, size, context, rotation }: DrawArgs): void {\n    this._basicSquare({ x, y, size, context, rotation });\n  }\n}\n","import { CornerDotTypes } from \"../types\";\n\nexport default {\n  dot: \"dot\",\n  square: \"square\"\n} as CornerDotTypes;\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"canvas\");;","import calculateImageSize from \"../tools/calculateImageSize\";\nimport errorCorrectionPercents from \"../constants/errorCorrectionPercents\";\nimport QRDot from \"./QRDot\";\nimport QRCornerSquare from \"./QRCornerSquare\";\nimport QRCornerDot from \"./QRCornerDot\";\nimport { RequiredOptions, Gradient } from \"./QROptions\";\nimport gradientTypes from \"../constants/gradientTypes\";\nimport { QRCode } from \"../types\";\n\nimport { Canvas, createCanvas, Image, loadImage, CanvasRenderingContext2D } from \"canvas\";\n\ntype FilterFunction = (i: number, j: number) => boolean;\n\nconst squareMask = [\n  [1, 1, 1, 1, 1, 1, 1],\n  [1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1],\n  [1, 0, 0, 0, 0, 0, 1],\n  [1, 1, 1, 1, 1, 1, 1]\n];\n\nconst dotMask = [\n  [0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0]\n];\n\nexport default class QRCanvas {\n  _canvas: Canvas;\n  _options: RequiredOptions;\n  _qr?: QRCode;\n  _image?: Image;\n\n  //TODO don't pass all options to this class\n  constructor(options: RequiredOptions) {\n    this._canvas = createCanvas(options.width, options.height);\n    this._options = options;\n  }\n\n  get context(): CanvasRenderingContext2D | null {\n    return this._canvas.getContext(\"2d\");\n  }\n\n  get width(): number {\n    return this._canvas.width;\n  }\n\n  get height(): number {\n    return this._canvas.height;\n  }\n\n  getCanvas(): Canvas {\n    return this._canvas;\n  }\n\n  clear(): void {\n    const canvasContext = this.context;\n\n    if (canvasContext) {\n      canvasContext.clearRect(0, 0, this._canvas.width, this._canvas.height);\n    }\n  }\n\n  async drawQR(qr: QRCode): Promise<void> {\n    const count = qr.getModuleCount();\n    const minSize = Math.min(this._options.width, this._options.height) - this._options.margin * 2;\n    const dotSize = Math.floor(minSize / count);\n    let drawImageSize = {\n      hideXDots: 0,\n      hideYDots: 0,\n      width: 0,\n      height: 0\n    };\n\n    this._qr = qr;\n\n    if (this._options.image) {\n      await this.loadImage();\n      if (!this._image) return;\n      const { imageOptions, qrOptions } = this._options;\n      const coverLevel = imageOptions.imageSize * errorCorrectionPercents[qrOptions.errorCorrectionLevel];\n      const maxHiddenDots = Math.floor(coverLevel * count * count);\n\n      drawImageSize = calculateImageSize({\n        originalWidth: this._image.width,\n        originalHeight: this._image.height,\n        maxHiddenDots,\n        maxHiddenAxisDots: count - 14,\n        dotSize\n      });\n    }\n\n    this.clear();\n    this.drawBackground();\n    this.drawDots((i: number, j: number): boolean => {\n      if (this._options.imageOptions.hideBackgroundDots) {\n        if (\n          i >= (count - drawImageSize.hideXDots) / 2 &&\n          i < (count + drawImageSize.hideXDots) / 2 &&\n          j >= (count - drawImageSize.hideYDots) / 2 &&\n          j < (count + drawImageSize.hideYDots) / 2\n        ) {\n          return false;\n        }\n      }\n\n      if (squareMask[i]?.[j] || squareMask[i - count + 7]?.[j] || squareMask[i]?.[j - count + 7]) {\n        return false;\n      }\n\n      if (dotMask[i]?.[j] || dotMask[i - count + 7]?.[j] || dotMask[i]?.[j - count + 7]) {\n        return false;\n      }\n\n      return true;\n    });\n    this.drawCorners();\n\n    if (this._options.image) {\n      this.drawImage({\n        width: drawImageSize.width,\n        height: drawImageSize.height,\n        count,\n        dotSize\n      });\n    }\n  }\n\n  drawBackground(): void {\n    const canvasContext = this.context;\n    const options = this._options;\n\n    if (canvasContext) {\n      if (options.backgroundOptions.gradient) {\n        const gradientOptions = options.backgroundOptions.gradient;\n        const gradient = this._createGradient({\n          context: canvasContext,\n          options: gradientOptions,\n          additionalRotation: 0,\n          x: 0,\n          y: 0,\n          size: this._canvas.width > this._canvas.height ? this._canvas.width : this._canvas.height\n        });\n\n        gradientOptions.colorStops.forEach(({ offset, color }: { offset: number; color: string }) => {\n          gradient.addColorStop(offset, color);\n        });\n\n        canvasContext.fillStyle = gradient;\n      } else if (options.backgroundOptions.color) {\n        canvasContext.fillStyle = options.backgroundOptions.color;\n      }\n      canvasContext.fillRect(0, 0, this._canvas.width, this._canvas.height);\n    }\n  }\n\n  drawDots(filter?: FilterFunction): void {\n    if (!this._qr) {\n      throw \"QR code is not defined\";\n    }\n\n    const canvasContext = this.context;\n\n    if (!canvasContext) {\n      throw \"QR code is not defined\";\n    }\n\n    const options = this._options;\n    const count = this._qr.getModuleCount();\n\n    if (count > options.width || count > options.height) {\n      throw \"The canvas is too small.\";\n    }\n\n    const minSize = Math.min(options.width, options.height) - options.margin * 2;\n    const dotSize = Math.floor(minSize / count);\n    const xBeginning = Math.floor((options.width - count * dotSize) / 2);\n    const yBeginning = Math.floor((options.height - count * dotSize) / 2);\n    const dot = new QRDot({\n      context: canvasContext,\n      type: options.dotsOptions.type\n    });\n\n    canvasContext.beginPath();\n\n    for (let i = 0; i < count; i++) {\n      for (let j = 0; j < count; j++) {\n        if (filter && !filter(i, j)) {\n          continue;\n        }\n        if (!this._qr.isDark(i, j)) {\n          continue;\n        }\n        dot.draw(\n          xBeginning + i * dotSize,\n          yBeginning + j * dotSize,\n          dotSize,\n          (xOffset: number, yOffset: number): boolean => {\n            if (i + xOffset < 0 || j + yOffset < 0 || i + xOffset >= count || j + yOffset >= count) return false;\n            if (filter && !filter(i + xOffset, j + yOffset)) return false;\n            return !!this._qr && this._qr.isDark(i + xOffset, j + yOffset);\n          }\n        );\n      }\n    }\n\n    if (options.dotsOptions.gradient) {\n      const gradientOptions = options.dotsOptions.gradient;\n      const gradient = this._createGradient({\n        context: canvasContext,\n        options: gradientOptions,\n        additionalRotation: 0,\n        x: xBeginning,\n        y: yBeginning,\n        size: count * dotSize\n      });\n\n      gradientOptions.colorStops.forEach(({ offset, color }: { offset: number; color: string }) => {\n        gradient.addColorStop(offset, color);\n      });\n\n      canvasContext.fillStyle = canvasContext.strokeStyle = gradient;\n    } else if (options.dotsOptions.color) {\n      canvasContext.fillStyle = canvasContext.strokeStyle = options.dotsOptions.color;\n    }\n\n    canvasContext.fill(\"evenodd\");\n  }\n\n  drawCorners(filter?: FilterFunction): void {\n    if (!this._qr) {\n      throw \"QR code is not defined\";\n    }\n\n    const canvasContext = this.context;\n\n    if (!canvasContext) {\n      throw \"QR code is not defined\";\n    }\n\n    const options = this._options;\n\n    const count = this._qr.getModuleCount();\n    const minSize = Math.min(options.width, options.height) - options.margin * 2;\n    const dotSize = Math.floor(minSize / count);\n    const cornersSquareSize = dotSize * 7;\n    const cornersDotSize = dotSize * 3;\n    const xBeginning = Math.floor((options.width - count * dotSize) / 2);\n    const yBeginning = Math.floor((options.height - count * dotSize) / 2);\n\n    [\n      [0, 0, 0],\n      [1, 0, Math.PI / 2],\n      [0, 1, -Math.PI / 2]\n    ].forEach(([column, row, rotation]) => {\n      if (filter && !filter(column, row)) {\n        return;\n      }\n\n      const x = xBeginning + column * dotSize * (count - 7);\n      const y = yBeginning + row * dotSize * (count - 7);\n\n      if (options.cornersSquareOptions?.type) {\n        const cornersSquare = new QRCornerSquare({\n          context: canvasContext,\n          type: options.cornersSquareOptions?.type\n        });\n\n        canvasContext.beginPath();\n        cornersSquare.draw(x, y, cornersSquareSize, rotation);\n      } else {\n        const dot = new QRDot({\n          context: canvasContext,\n          type: options.dotsOptions.type\n        });\n\n        canvasContext.beginPath();\n\n        for (let i = 0; i < squareMask.length; i++) {\n          for (let j = 0; j < squareMask[i].length; j++) {\n            if (!squareMask[i]?.[j]) {\n              continue;\n            }\n\n            dot.draw(\n              x + i * dotSize,\n              y + j * dotSize,\n              dotSize,\n              (xOffset: number, yOffset: number): boolean => !!squareMask[i + xOffset]?.[j + yOffset]\n            );\n          }\n        }\n      }\n\n      if (options.cornersSquareOptions?.gradient) {\n        const gradientOptions = options.cornersSquareOptions.gradient;\n        const gradient = this._createGradient({\n          context: canvasContext,\n          options: gradientOptions,\n          additionalRotation: rotation,\n          x,\n          y,\n          size: cornersSquareSize\n        });\n\n        gradientOptions.colorStops.forEach(({ offset, color }: { offset: number; color: string }) => {\n          gradient.addColorStop(offset, color);\n        });\n\n        canvasContext.fillStyle = canvasContext.strokeStyle = gradient;\n      } else if (options.cornersSquareOptions?.color) {\n        canvasContext.fillStyle = canvasContext.strokeStyle = options.cornersSquareOptions.color;\n      }\n\n      canvasContext.fill(\"evenodd\");\n\n      if (options.cornersDotOptions?.type) {\n        const cornersDot = new QRCornerDot({\n          context: canvasContext,\n          type: options.cornersDotOptions?.type\n        });\n\n        canvasContext.beginPath();\n        cornersDot.draw(x + dotSize * 2, y + dotSize * 2, cornersDotSize, rotation);\n      } else {\n        const dot = new QRDot({\n          context: canvasContext,\n          type: options.dotsOptions.type\n        });\n\n        canvasContext.beginPath();\n\n        for (let i = 0; i < dotMask.length; i++) {\n          for (let j = 0; j < dotMask[i].length; j++) {\n            if (!dotMask[i]?.[j]) {\n              continue;\n            }\n\n            dot.draw(\n              x + i * dotSize,\n              y + j * dotSize,\n              dotSize,\n              (xOffset: number, yOffset: number): boolean => !!dotMask[i + xOffset]?.[j + yOffset]\n            );\n          }\n        }\n      }\n\n      if (options.cornersDotOptions?.gradient) {\n        const gradientOptions = options.cornersDotOptions.gradient;\n        const gradient = this._createGradient({\n          context: canvasContext,\n          options: gradientOptions,\n          additionalRotation: rotation,\n          x: x + dotSize * 2,\n          y: y + dotSize * 2,\n          size: cornersDotSize\n        });\n\n        gradientOptions.colorStops.forEach(({ offset, color }: { offset: number; color: string }) => {\n          gradient.addColorStop(offset, color);\n        });\n\n        canvasContext.fillStyle = canvasContext.strokeStyle = gradient;\n      } else if (options.cornersDotOptions?.color) {\n        canvasContext.fillStyle = canvasContext.strokeStyle = options.cornersDotOptions.color;\n      }\n\n      canvasContext.fill(\"evenodd\");\n    });\n  }\n\n  async loadImage(): Promise<void> {\n    const options = this._options;\n\n    if (!options.image) {\n      throw new Error(\"Image is not defined\");\n    }\n\n    // if (typeof options.imageOptions.crossOrigin === \"string\") {\n    //     image.crossOrigin = options.imageOptions.crossOrigin;\n    // }\n\n    this._image = await loadImage(options.image);\n  }\n\n  drawImage({\n    width,\n    height,\n    count,\n    dotSize\n  }: {\n    width: number;\n    height: number;\n    count: number;\n    dotSize: number;\n  }): void {\n    const canvasContext = this.context;\n\n    if (!canvasContext) {\n      throw \"canvasContext is not defined\";\n    }\n\n    if (!this._image) {\n      throw \"image is not defined\";\n    }\n\n    const options = this._options;\n    const xBeginning = Math.floor((options.width - count * dotSize) / 2);\n    const yBeginning = Math.floor((options.height - count * dotSize) / 2);\n    const dx = xBeginning + options.imageOptions.margin + (count * dotSize - width) / 2;\n    const dy = yBeginning + options.imageOptions.margin + (count * dotSize - height) / 2;\n    const dw = width - options.imageOptions.margin * 2;\n    const dh = height - options.imageOptions.margin * 2;\n\n    canvasContext.drawImage(this._image, dx, dy, dw < 0 ? 0 : dw, dh < 0 ? 0 : dh);\n  }\n\n  _createGradient({\n    context,\n    options,\n    additionalRotation,\n    x,\n    y,\n    size\n  }: {\n    context: CanvasRenderingContext2D;\n    options: Gradient;\n    additionalRotation: number;\n    x: number;\n    y: number;\n    size: number;\n  }): CanvasGradient {\n    let gradient;\n\n    if (options.type === gradientTypes.radial) {\n      gradient = context.createRadialGradient(x + size / 2, y + size / 2, 0, x + size / 2, y + size / 2, size / 2);\n    } else {\n      const rotation = ((options.rotation || 0) + additionalRotation) % (2 * Math.PI);\n      const positiveRotation = (rotation + 2 * Math.PI) % (2 * Math.PI);\n      let x0 = x + size / 2;\n      let y0 = y + size / 2;\n      let x1 = x + size / 2;\n      let y1 = y + size / 2;\n\n      if (\n        (positiveRotation >= 0 && positiveRotation <= 0.25 * Math.PI) ||\n        (positiveRotation > 1.75 * Math.PI && positiveRotation <= 2 * Math.PI)\n      ) {\n        x0 = x0 - size / 2;\n        y0 = y0 - (size / 2) * Math.tan(rotation);\n        x1 = x1 + size / 2;\n        y1 = y1 + (size / 2) * Math.tan(rotation);\n      } else if (positiveRotation > 0.25 * Math.PI && positiveRotation <= 0.75 * Math.PI) {\n        y0 = y0 - size / 2;\n        x0 = x0 - size / 2 / Math.tan(rotation);\n        y1 = y1 + size / 2;\n        x1 = x1 + size / 2 / Math.tan(rotation);\n      } else if (positiveRotation > 0.75 * Math.PI && positiveRotation <= 1.25 * Math.PI) {\n        x0 = x0 + size / 2;\n        y0 = y0 + (size / 2) * Math.tan(rotation);\n        x1 = x1 - size / 2;\n        y1 = y1 - (size / 2) * Math.tan(rotation);\n      } else if (positiveRotation > 1.25 * Math.PI && positiveRotation <= 1.75 * Math.PI) {\n        y0 = y0 + size / 2;\n        x0 = x0 + size / 2 / Math.tan(rotation);\n        y1 = y1 - size / 2;\n        x1 = x1 - size / 2 / Math.tan(rotation);\n      }\n\n      gradient = context.createLinearGradient(Math.round(x0), Math.round(y0), Math.round(x1), Math.round(y1));\n    }\n\n    return gradient;\n  }\n}\n","interface ImageSizeOptions {\n  originalHeight: number;\n  originalWidth: number;\n  maxHiddenDots: number;\n  maxHiddenAxisDots?: number;\n  dotSize: number;\n}\n\ninterface ImageSizeResult {\n  height: number;\n  width: number;\n  hideYDots: number;\n  hideXDots: number;\n}\n\nexport default function calculateImageSize({\n  originalHeight,\n  originalWidth,\n  maxHiddenDots,\n  maxHiddenAxisDots,\n  dotSize\n}: ImageSizeOptions): ImageSizeResult {\n  const hideDots = { x: 0, y: 0 };\n  const imageSize = { x: 0, y: 0 };\n\n  if (originalHeight <= 0 || originalWidth <= 0 || maxHiddenDots <= 0 || dotSize <= 0) {\n    return {\n      height: 0,\n      width: 0,\n      hideYDots: 0,\n      hideXDots: 0\n    };\n  }\n\n  const k = originalHeight / originalWidth;\n\n  //Getting the maximum possible axis hidden dots\n  hideDots.x = Math.floor(Math.sqrt(maxHiddenDots / k));\n  //The count of hidden dot's can't be less than 1\n  if (hideDots.x <= 0) hideDots.x = 1;\n  //Check the limit of the maximum allowed axis hidden dots\n  if (maxHiddenAxisDots && maxHiddenAxisDots < hideDots.x) hideDots.x = maxHiddenAxisDots;\n  //The count of dots should be odd\n  if (hideDots.x % 2 === 0) hideDots.x--;\n  imageSize.x = hideDots.x * dotSize;\n  //Calculate opposite axis hidden dots based on axis value.\n  //The value will be odd.\n  //We use ceil to prevent dots covering by the image.\n  hideDots.y = 1 + 2 * Math.ceil((hideDots.x * k - 1) / 2);\n  imageSize.y = Math.round(imageSize.x * k);\n  //If the result dots count is bigger than max - then decrease size and calculate again\n  if (hideDots.y * hideDots.x > maxHiddenDots || (maxHiddenAxisDots && maxHiddenAxisDots < hideDots.y)) {\n    if (maxHiddenAxisDots && maxHiddenAxisDots < hideDots.y) {\n      hideDots.y = maxHiddenAxisDots;\n      if (hideDots.y % 2 === 0) hideDots.x--;\n    } else {\n      hideDots.y -= 2;\n    }\n    imageSize.y = hideDots.y * dotSize;\n    hideDots.x = 1 + 2 * Math.ceil((hideDots.y / k - 1) / 2);\n    imageSize.x = Math.round(imageSize.y / k);\n  }\n\n  return {\n    height: imageSize.y,\n    width: imageSize.x,\n    hideYDots: hideDots.y,\n    hideXDots: hideDots.x\n  };\n}\n","import { GradientTypes } from \"../types\";\n\nexport default {\n  radial: \"radial\",\n  linear: \"linear\"\n} as GradientTypes;\n","import { TypeNumber } from \"../types\";\n\ninterface TypesMap {\n  [key: number]: TypeNumber;\n}\n\nconst qrTypes: TypesMap = {};\n\nfor (let type = 0; type <= 40; type++) {\n  qrTypes[type] = type as TypeNumber;\n}\n\n// 0 types is autodetect\n\n// types = {\n//     0: 0,\n//     1: 1,\n//     ...\n//     40: 40\n// }\n\nexport default qrTypes;\n","import qrTypes from \"../constants/qrTypes\";\nimport errorCorrectionLevels from \"../constants/errorCorrectionLevels\";\nimport {\n  DotType,\n  GradientType,\n  CornerSquareType,\n  CornerDotType,\n  TypeNumber,\n  ErrorCorrectionLevel,\n  Mode\n} from \"../types\";\n\nexport type Gradient = {\n  type: GradientType;\n  rotation?: number;\n  colorStops: {\n    offset: number;\n    color: string;\n  }[];\n};\n\nexport type Options = {\n  width?: number;\n  height?: number;\n  data?: string;\n  image?: string;\n  qrOptions?: {\n    typeNumber?: TypeNumber;\n    mode?: Mode;\n    errorCorrectionLevel?: ErrorCorrectionLevel;\n  };\n  imageOptions?: {\n    hideBackgroundDots?: boolean;\n    imageSize?: number;\n    crossOrigin?: string;\n    margin?: number;\n  };\n  dotsOptions?: {\n    type?: DotType;\n    color?: string;\n    gradient?: Gradient;\n  };\n  cornersSquareOptions?: {\n    type?: CornerSquareType;\n    color?: string;\n    gradient?: Gradient;\n  };\n  cornersDotOptions?: {\n    type?: CornerDotType;\n    color?: string;\n    gradient?: Gradient;\n  };\n  backgroundOptions?: {\n    color?: string;\n    gradient?: Gradient;\n  };\n};\n\nexport interface RequiredOptions extends Options {\n  width: number;\n  height: number;\n  margin: number;\n  data: string;\n  qrOptions: {\n    typeNumber: TypeNumber;\n    mode?: Mode;\n    errorCorrectionLevel: ErrorCorrectionLevel;\n  };\n  imageOptions: {\n    hideBackgroundDots: boolean;\n    imageSize: number;\n    crossOrigin?: string;\n    margin: number;\n  };\n  dotsOptions: {\n    type: DotType;\n    color: string;\n    gradient?: Gradient;\n  };\n  backgroundOptions: {\n    color: string;\n    gradient?: Gradient;\n  };\n}\n\nconst defaultOptions: RequiredOptions = {\n  width: 300,\n  height: 300,\n  data: \"\",\n  margin: 0,\n  qrOptions: {\n    typeNumber: qrTypes[0],\n    mode: undefined,\n    errorCorrectionLevel: errorCorrectionLevels.Q\n  },\n  imageOptions: {\n    hideBackgroundDots: true,\n    imageSize: 0.4,\n    crossOrigin: undefined,\n    margin: 0\n  },\n  dotsOptions: {\n    type: \"square\",\n    color: \"#000\"\n  },\n  backgroundOptions: {\n    color: \"#fff\"\n  }\n};\n\nexport default defaultOptions;\n","import { ErrorCorrectionLevel } from \"../types\";\n\ninterface ErrorCorrectionLevels {\n  [key: string]: ErrorCorrectionLevel;\n}\n\nexport default {\n  L: \"L\",\n  M: \"M\",\n  Q: \"Q\",\n  H: \"H\"\n} as ErrorCorrectionLevels;\n","import { Gradient, RequiredOptions } from \"../core/QROptions\";\n\nfunction sanitizeGradient(gradient: Gradient): Gradient {\n  const newGradient = { ...gradient };\n\n  if (!newGradient.colorStops || !newGradient.colorStops.length) {\n    throw \"Field 'colorStops' is required in gradient\";\n  }\n\n  if (newGradient.rotation) {\n    newGradient.rotation = Number(newGradient.rotation);\n  } else {\n    newGradient.rotation = 0;\n  }\n\n  newGradient.colorStops = newGradient.colorStops.map((colorStop: { offset: number; color: string }) => ({\n    ...colorStop,\n    offset: Number(colorStop.offset)\n  }));\n\n  return newGradient;\n}\n\nexport default function sanitizeOptions(options: RequiredOptions): RequiredOptions {\n  const newOptions = { ...options };\n\n  newOptions.width = Number(newOptions.width);\n  newOptions.height = Number(newOptions.height);\n  newOptions.margin = Number(newOptions.margin);\n  newOptions.imageOptions = {\n    ...newOptions.imageOptions,\n    hideBackgroundDots: Boolean(newOptions.imageOptions.hideBackgroundDots),\n    imageSize: Number(newOptions.imageOptions.imageSize),\n    margin: Number(newOptions.imageOptions.margin)\n  };\n\n  if (newOptions.margin > Math.min(newOptions.width, newOptions.height)) {\n    newOptions.margin = Math.min(newOptions.width, newOptions.height);\n  }\n\n  newOptions.dotsOptions = {\n    ...newOptions.dotsOptions\n  };\n  if (newOptions.dotsOptions.gradient) {\n    newOptions.dotsOptions.gradient = sanitizeGradient(newOptions.dotsOptions.gradient);\n  }\n\n  if (newOptions.cornersSquareOptions) {\n    newOptions.cornersSquareOptions = {\n      ...newOptions.cornersSquareOptions\n    };\n    if (newOptions.cornersSquareOptions.gradient) {\n      newOptions.cornersSquareOptions.gradient = sanitizeGradient(newOptions.cornersSquareOptions.gradient);\n    }\n  }\n\n  if (newOptions.cornersDotOptions) {\n    newOptions.cornersDotOptions = {\n      ...newOptions.cornersDotOptions\n    };\n    if (newOptions.cornersDotOptions.gradient) {\n      newOptions.cornersDotOptions.gradient = sanitizeGradient(newOptions.cornersDotOptions.gradient);\n    }\n  }\n\n  if (newOptions.backgroundOptions) {\n    newOptions.backgroundOptions = {\n      ...newOptions.backgroundOptions\n    };\n    if (newOptions.backgroundOptions.gradient) {\n      newOptions.backgroundOptions.gradient = sanitizeGradient(newOptions.backgroundOptions.gradient);\n    }\n  }\n\n  return newOptions;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"qrcode-generator\");;","import QRCodeStyling from \"./core/QRCodeStyling\";\nimport dotTypes from \"./constants/dotTypes\";\nimport cornerDotTypes from \"./constants/cornerDotTypes\";\nimport cornerSquareTypes from \"./constants/cornerSquareTypes\";\nimport errorCorrectionLevels from \"./constants/errorCorrectionLevels\";\nimport errorCorrectionPercents from \"./constants/errorCorrectionPercents\";\nimport modes from \"./constants/modes\";\nimport qrTypes from \"./constants/qrTypes\";\n\nexport { dotTypes, cornerDotTypes, cornerSquareTypes, errorCorrectionLevels, errorCorrectionPercents, modes, qrTypes };\nexport default QRCodeStyling;\n","import getMode from \"../tools/getMode\";\nimport mergeDeep from \"../tools/merge\";\nimport QRCanvas from \"./QRCanvas\";\nimport defaultOptions, { Options, RequiredOptions } from \"./QROptions\";\nimport sanitizeOptions from \"../tools/sanitizeOptions\";\nimport { QRCode } from \"../types\";\nimport qrcode from \"qrcode-generator\";\nimport { Canvas, PngConfig } from \"canvas\";\n\nexport default class QRCodeStyling {\n  _options: RequiredOptions;\n  _canvas?: QRCanvas;\n  _qr?: QRCode;\n\n  constructor(options?: Partial<Options>) {\n    this._options = options ? sanitizeOptions(mergeDeep(defaultOptions, options) as RequiredOptions) : defaultOptions;\n  }\n\n  public async draw(options?: Partial<Options>): Promise<QRCodeStyling> {\n    this._options = options ? sanitizeOptions(mergeDeep(this._options, options) as RequiredOptions) : this._options;\n\n    if (!this._options.data) {\n      throw new Error(\"Data isn`t defined\");\n    }\n\n    this._qr = qrcode(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel);\n    this._qr.addData(this._options.data, this._options.qrOptions.mode || getMode(this._options.data));\n    this._qr.make();\n    this._canvas = new QRCanvas(this._options);\n    await this._canvas.drawQR(this._qr);\n    return this;\n  }\n\n  public getCanvas(): Canvas | undefined {\n    return this._canvas?.getCanvas();\n  }\n\n  toPNGBuffer(options?: PngConfig): Buffer | undefined {\n    return this._canvas?.getCanvas().toBuffer(\"image/png\", options);\n  }\n\n  toSVGBuffer(): Buffer | undefined {\n    return this._canvas?.getCanvas().toBuffer();\n  }\n}\n","import modes from \"../constants/modes\";\nimport { Mode } from \"../types\";\n\nexport default function getMode(data: string): Mode {\n  switch (true) {\n    case /^[0-9]*$/.test(data):\n      return modes.numeric;\n    case /^[0-9A-Z $%*+\\-./:]*$/.test(data):\n      return modes.alphanumeric;\n    default:\n      return modes.byte;\n  }\n}\n","import { Mode } from \"../types\";\n\ninterface Modes {\n  [key: string]: Mode;\n}\n\nexport default {\n  numeric: \"Numeric\",\n  alphanumeric: \"Alphanumeric\",\n  byte: \"Byte\",\n  kanji: \"Kanji\"\n} as Modes;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(__webpack_module_cache__[moduleId]) {\n\t\treturn __webpack_module_cache__[moduleId].exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// module exports must be returned from runtime so entry inlining is disabled\n// startup\n// Load entry module and return exports\nreturn __webpack_require__(423);\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => module['default'] :\n\t\t() => module;\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)"],"sourceRoot":""}